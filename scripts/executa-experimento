#!/bin/bash

# Arquivo: executa-experimento

box(){
    local LANG="C.UTF-8" LC_ALL="C.UTF-8"
    local sentence="$(printf "%b\n" "$@")"

    local ansi_re=$'\033\\[(1;31|1;32|1;33|1;36|1;95|0)m'
    local cleanedSentence=$(printf '%b' "$sentence" | sed -E $'s/\033\\[[0-9;]*m//g; s/^[[:space:]]*//; s/[[:space:]]*$//')

    local leftUpperCornerSymbol="╔"
    local rightUpperCornerSymbol="╗"
    local leftBottomCornerSymbol="╚"
    local rightBottomCornerSymbol="╝"
    local horizontalSymbol="═"
    local verticalSymbol="║"

    # Gets the bigger length
    local lineLength=0
    local currentLineLength=0
    while read -r line; do
        currentLineLength=${#line}
        if [ $currentLineLength -gt $lineLength ]; then
            lineLength=$currentLineLength
        fi

    done <<< "$cleanedSentence"

    # Adds two to create additional length
    local horizontalSpacing=$(($lineLength+2))

    # Create a horizontal line with horizontalSpacing length
    for pos in $(seq 1 $horizontalSpacing)
    do
        local horizontalLine=$horizontalSymbol$horizontalLine
    done

    # Draws the box with multiline text inside
    echo "$leftUpperCornerSymbol$horizontalLine$rightUpperCornerSymbol"
    echo "$verticalSymbol${horizontalLine//$horizontalSymbol/ }$verticalSymbol"

    local horizontalRightSpacing=0
    while read -r line && read -r cleanedLine <&3; do
        local additionalSpace=""
        lineLength=${#cleanedLine}
        horizontalRightSpacing=$((horizontalSpacing - lineLength - 2))
        for pos in $(seq 1 $horizontalRightSpacing); do
            additionalSpace=" $additionalSpace"
        done

        echo -e "$verticalSymbol $line $additionalSpace$verticalSymbol"
    done < <(printf '%s\n' "$sentence") 3< <(printf '%s\n' "$cleanedSentence")

    echo "$verticalSymbol${horizontalLine//$horizontalSymbol/ }$verticalSymbol"
    echo "$leftBottomCornerSymbol$horizontalLine$rightBottomCornerSymbol"

    export boxWidth=$(( ${#horizontalLine} + 2 ))
}

## Funções que tratam da receita de testes ##
obtem_nome_receita() {
    local conteudo_receita="$1"
    local nome_receita=""
    local dentro_receita=false

    while IFS= read -r linha; do
        linha="${linha#"${linha%%[![:space:]]*}"}"
        linha="${linha%"${linha##*[![:space:]]}"}"

        # Detecta início da seção [Receita]
        if [[ "$linha" =~ ^\[Receita\]$ ]]; then
            dentro_receita=true
            continue
        fi

        # Sai ao entrar em outra seção
        if [[ "$linha" =~ ^\[.*\]$ ]] && $dentro_receita; then
            break
        fi

        # Se está dentro da seção [Receita] e encontrou Nome=
        if [[ $dentro_receita && "$linha" =~ ^Nome= ]]; then
            nome_receita="${linha#Nome=}"
            break
        fi
    done <<< "$conteudo_receita"

    # Sanitização do nome
    nome_receita=$(echo "$nome_receita" | sed 's/ \+/_/g' | tr -cd '[:alnum:]_')
    nome_receita=$(echo "$nome_receita" | sed 's/_\+$//')

    echo "$nome_receita"
}

obtem_descricao_receita() {
    local conteudo_receita="$1"
    local descricao=""
    local dentro_receita=false

    while IFS= read -r linha; do
        # Remove espaços extras no início/fim da linha
        linha="${linha#"${linha%%[![:space:]]*}"}"
        linha="${linha%"${linha##*[![:space:]]}"}"

        # Detecta início da seção [Receita]
        if [[ "$linha" =~ ^\[Receita\]$ ]]; then
            dentro_receita=true
            continue
        fi

        # Sai ao entrar em outra seção
        if [[ "$linha" =~ ^\[.*\]$ ]] && $dentro_receita; then
            break
        fi

        # Se está dentro da seção [Receita] e encontrou Descricao=
        if [[ $dentro_receita && "$linha" =~ ^Descricao= ]]; then
            descricao="${linha#Descricao=}"
            break
        fi
    done <<< "$conteudo_receita"

    echo "$descricao"
}

obtem_rodadas() {
    local conteudo_receita="$1"
    local rodadas=0

    while IFS= read -r linha; do
        if [[ "$linha" =~ ^Rodadas= ]]; then
            rodadas="${linha#Rodadas=}"
            break
        fi
    done <<< "$conteudo_receita"

    echo "$rodadas"
}

obtem_tempo_da_rodada() {
    local conteudo_receita="$1"
    local tempo_da_rodada=""

    while IFS= read -r linha; do
        if [[ "$linha" =~ ^TempoDaRodada= ]]; then
            tempo_da_rodada="${linha#TempoDaRodada=}"
            break
        fi
    done <<< "$conteudo_receita"

    echo "$tempo_da_rodada"
}

obtem_sumarizador() {
    local conteudo_receita="$1"
    local sumarizador=""

    while IFS= read -r linha; do
        if [[ "$linha" =~ ^Sumarizador= ]]; then
            sumarizador="${linha#Sumarizador=}"
            break
        fi
    done <<< "$conteudo_receita"

    echo "$sumarizador"
}

obtem_quantidade_testes() {
    local conteudo_receita="$1"
    local quantidade_testes=0

    while IFS= read -r linha; do
        if [[ "$linha" =~ ^\[Teste\]$ ]]; then
            ((quantidade_testes++))
        fi
    done <<< "$conteudo_receita"

    echo "$quantidade_testes"
}

obtem_nome_teste() {
    local conteudo_receita="$1"
    local numero_teste="$2"
    local nome_teste=""
    local contador=0
    local dentro_do_teste=0

    while IFS= read -r linha; do
        if [[ "$linha" =~ ^\[Teste\]$ ]]; then
            ((contador++))
            dentro_do_teste=1
            continue
        fi

        if [[ $dentro_do_teste -eq 1 && "$linha" == Nome=* ]]; then
            if [[ $contador -eq $numero_teste ]]; then
                nome_teste="${linha#Nome=}"
                break
            fi
            dentro_do_teste=0
        fi
    done <<< "$conteudo_receita"
    echo "$nome_teste"
}

obtem_nomes_testes() {
    local conteudo_receita="$1"
    local nomes_testes=()
    local contador=0
    local dentro_do_teste=0

    while IFS= read -r linha; do
        if [[ "$linha" =~ ^\[Teste\]$ ]]; then
            dentro_do_teste=1
            continue
        fi

        if [[ $dentro_do_teste -eq 1 && "$linha" == Nome=* ]]; then
            nomes_testes+=("${linha#Nome=}")
            dentro_do_teste=0
        fi
    done <<< "$conteudo_receita"

    for nome_teste in "${nomes_testes[@]}"; do
        echo "$nome_teste"
    done
}

obtem_teste() {
    local conteudo_receita="$1"
    local nome_teste_informado="$2"
    local dentro_do_teste=0
    preparo_antes=""
    preparo_depois=""
    comando_cliente=""
    comando_servidor=""
    descricao_teste=""

    local lines
    readarray -t lines <<< "$conteudo_receita"

    local linha valor
    for linha in "${lines[@]}"; do
        # detecta início de bloco [Teste]
        if [[ "$linha" == "[Teste]" ]]; then
            dentro_do_teste=0
            continue
        fi

        # identifica nome do teste
        if [[ "$linha" == Nome=* ]]; then
            valor="${linha#Nome=}"
            if [[ "$valor" == "$nome_teste_informado" ]]; then
                dentro_do_teste=1
            fi
            continue
        fi

        # se estamos dentro do teste certo, extrai os campos
        if (( dentro_do_teste )); then
            case "$linha" in
                Descricao=*)
                    descricao_teste="${linha#Descricao=}"
                    ;;
                PreparoAntes=*)
                    preparo_antes="${linha#PreparoAntes=}"
                    ;;
                PreparoDepois=*)
                    preparo_depois="${linha#PreparoDepois=}"
                    ;;
                ComandoCliente=*)
                    comando_cliente="${linha#ComandoCliente=}"
                    ;;
                ComandoServidor=*)
                    comando_servidor="${linha#ComandoServidor=}"
                    if [ -z "$comando_servidor" ]; then
                        comando_servidor=true
                    fi
                    ;;
            esac
        fi
    done
}
## Fim das funções que tratam da receita de testes ##

obtem_duracao_do_comando_iperf(){
    local comando_cliente="$1"
    local comando_iperf3_cliente=$(echo $comando_cliente | sed 's/.*\(iperf3 .*\)/\1/')

    echo $comando_iperf3_cliente | awk '{ while (match($0, /-t[ ]*([0-9]+)/, a)) { val=a[1]; $0=substr($0, RSTART+RLENGTH) } } END { if(val) print val }'
}

obtem_quantidade_amostras_omitidas(){
    local comando_iperf3="$1"
    local quantidade_amostras_omitidas=0

    # Deverá retornar zero se não houver a opção -O ou --omit
    if ! echo $comando_iperf3 | grep -qE '(-O|--omit)[ ]*([0-9]+)'; then
        echo 0
        return
    fi

    quantidade_amostras_omitidas=$(echo $comando_iperf3 | awk 'match($0, /-O[ ]*([0-9]+)/, a) { val=a[1] } END { if(val) print val }')
    if [ -z "$quantidade_amostras_omitidas" ]; then
        quantidade_amostras_omitidas=$(echo $comando_iperf3 | awk 'match($0, /--omit[ ]*([0-9]+)/, a) { val=a[1] } END { if(val) print val }')
    fi

    echo $quantidade_amostras_omitidas
}

verifica_conexao_servidor_iperf3(){
    local comando_cliente="$1"
    local comando_iperf3_cliente=$(echo "$comando_cliente" | sed 's/.*\(iperf3 .*\)/\1/')
    local endereco_servidor=""
    local porta=5201

    # Obtém o endereço do servidor a partir do comando do cliente
    endereco_servidor=$(echo "$comando_iperf3_cliente" | awk '{
        while (match($0, /(-c|--client)[[:space:]]+([^[:space:]]+)/, a)) {
            val = a[2]
            if (substr(val, 1, 1) != "-") {
                print val
                exit
            }
            $0 = substr($0, RSTART + RLENGTH)
        }
    }')

    # Se não encontrou endereço, não é um comando de cliente válido
    if [ -z "$endereco_servidor" ]; then
        return 1
    fi

    # Obtém a porta do servidor a partir do comando do cliente
    local porta_extraida=$(echo "$comando_iperf3_cliente" | awk '{
        if (match($0, /(-p|--port)[[:space:]]+([0-9]+)/, a)) {
            print a[2]
        }
    }')

    if [ -n "$porta_extraida" ]; then
        porta=$porta_extraida
    fi

    # Testa conexão TCP usando /dev/tcp do bash, com timeout de 2 segundos
    if command -v timeout >/dev/null 2>&1; then
        if timeout 2 bash -c "echo > /dev/tcp/$endereco_servidor/$porta" 2>/dev/null; then
            return 0
        else
            return 1
        fi
    else
        # Fallback: tenta conexão sem timeout, que pode travar se o servidor não responder
        if (exec 3<>/dev/tcp/$endereco_servidor/$porta) 2>/dev/null; then
            exec 3<&-
            exec 3>&-
            return 0
        else
            return 1
        fi
    fi
}

verifica_dependencias(){
    # Verifica se as dependências do sistema necessárias estão instaladas
    dependencias=(numactl python3 jq)
    dependencia_faltante=()

    for dependencia in ${dependencias[@]}; do
        if ! command -v $dependencia &> /dev/null; then
            dependencia_faltante+=($dependencia)
        fi
    done

    if [ ${#dependencia_faltante[@]} -gt 0 ]; then
        echo -e "${vermelho}Erro: as dependências necessárias não estão instaladas:${normal}"
        for dependencia in ${dependencia_faltante[@]}; do
            echo -e "${vermelho}  - $dependencia${normal}"
        done
        exit 1
    fi

    # Verifica se as dependências do Python necessárias estão instaladas
    modulos=(pandas matplotlib.pyplot numpy sys json csv re)
    modulos_false=()

    for modulo in ${modulos[@]}; do
        if ! python3 -c "import $modulo" &> /dev/null; then
            modulos_false+=($modulo)
        fi
    done

    if [ ${#modulos_false[@]} -gt 0 ]; then
        echo -e "${vermelho}Erro: as dependências necessárias não estão instaladas:${normal}"
        for modulo in ${modulos_false[@]}; do
            echo -e "${vermelho}  - $modulo${normal}"
        done
        exit 1
    fi
}

contagem_regressiva(){
    local valor_inicial=$1
    local valor_extra=$2
    local texto="$3"
    local contagem_atual=0
    local contagem_extra=$valor_extra

    for i in $(seq $((valor_inicial + valor_extra)) -1 1); do
        printf "\033[K"
        contagem_atual=$i

        if [ "$contagem_atual" -gt "$valor_inicial" ]; then
            printf "$texto ${ciano}[Tempo restante: $valor_inicial][+${contagem_extra}]${normal}\r"
            contagem_extra=$((contagem_extra - 1))
        else
            printf "$texto ${ciano}[Tempo restante: $contagem_atual]${normal}\r"
        fi

        sleep 1
    done

    printf "\033[K"
    printf "$texto"
    echo -e '\r'
}

mostrar_e_registrar(){
    local texto="$1"
    local arquivo_log="$2"

    echo -e "$texto" | tee >(sed $'s/\033[[][^A-Za-z]*m//g' >> "$arquivo_log")
}

roda_teste(){
    local rodada_atual="$1"
    local comando_cliente="$2"
    local comando_servidor="$3"
    local duracao="$4"
    local dir_resultados_teste="$5"
    local apelido="$6"
    local log_teste="$7"
    local nucleo_servidor=""
    local nucleo_cliente=""
    local nucleo=""
    local texto_banda=""
    local args_extras=""
    local quantidade_amostras_omitidas=0

    local comando_iperf3_cliente=$(echo $comando_cliente | sed 's/.*\(iperf3 .*\)/\1/')
    local comando_iperf3_servidor=$(echo $comando_servidor | sed 's/.*\(iperf3 .*\)/\1/')

    local banda=$(echo $comando_iperf3_cliente | awk '{ while (match($0, /-b[[:space:]]*([^[:space:]]+)/, a)) { val=a[1]; $0=substr($0, RSTART+RLENGTH) } } END { if (val) print val }')
    local quantidade_fluxos=$(echo $comando_iperf3_cliente | awk '{ while (match($0, /-P[ ]*([0-9]+)/, a)) { val=a[1]; $0=substr($0, RSTART+RLENGTH) } } END { if(val) print val }')

    # Verificando se há medições omitidas no comando do cliente
    quantidade_amostras_omitidas=$(obtem_quantidade_amostras_omitidas "$comando_iperf3_cliente")

    # Verificando se o comando do cliente possui o núcleo do servidor
    nucleo=$(echo $comando_iperf3_cliente | awk 'match($0, /-A[ ]*([0-9]+(,[0-9]+)*)/, a) { val=a[1] } END { if(val) print val }')

    if [ -n "$nucleo" ]; then
        # Se o núcleo estiver no formato "nucleo_cliente,nucleo_servidor"
        if [[ $nucleo =~ ^[0-9]+,[0-9]+$ ]]; then
            nucleo_cliente=$(echo $nucleo | cut -d',' -f1)
            nucleo_servidor=$(echo $nucleo | cut -d',' -f2)

            texto_nucleo_servidor=" no núcleo ${nucleo_servidor}"
        elif [[ $nucleo =~ ^[0-9]+$ ]]; then
            # Se houver apenas um número como valor do argumento -A
            nucleo_cliente=$nucleo
        fi

        texto_nucleo_cliente=" no núcleo ${nucleo_cliente}"
    fi

    if [ -z "$nucleo_servidor" ]; then
        # Verifica se o comando do servidor possui o núcleo do servidor
        nucleo_servidor=$(echo $comando_iperf3_servidor | awk 'match($0, /-A[ ]*([0-9]+(,[0-9]+)*)/, a) { val=a[1] } END { if(val) print val }')

        if [ -n "$nucleo_servidor" ]; then
            texto_nucleo_servidor=" no núcleo ${nucleo_servidor}"
        fi
    fi

    if [ "$quantidade_amostras_omitidas" -eq 1 ]; then
        texto_quantidade_amostras_omitidas=" e com ${quantidade_amostras_omitida} medição omitida"
    elif [ "$quantidade_amostras_omitidas" -gt 1 ]; then
        texto_quantidade_amostras_omitidas=" e com ${quantidade_amostras_omitidas} medições omitidas"
    else
        texto_quantidade_amostras_omitidas=""
    fi

    if [ -z "$banda" ]; then
        texto_banda=", sem limite de banda"
    else
        texto_banda=", com banda de ${banda}"
    fi

    mostrar_e_registrar "\n${verde}Executando a rodada $rodada_atual do teste de $duracao segundos${texto_banda}${texto_quantidade_amostras_omitidas}...${normal}\n" "$log_teste"
    mkdir -p $dir_resultados_teste/rodada_$rodada_atual

    if [ -n "$comando_servidor" ]; then
        mostrar_e_registrar "${amarelo}Servidor iniciado${texto_nucleo_servidor}...${normal}" "$log_teste"

        arquivo_erro_servidor="$dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-iperf3_server_erro.log"

        $comando_servidor -J --one-off -i 1 > $dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-iperf3_server.json 2> "$arquivo_erro_servidor" < /dev/null &
        pid_servidor=$!

        # Verifica se o servidor iperf3 ainda está rodando e encerra se não estiver
        sleep 0.5
        if ! kill -0 $pid_servidor 2>/dev/null; then
            wait $pid_servidor
            resultado_servidor_iperf3=$?
            mensagem_erro_servidor=""
            if [ -f "$arquivo_erro_servidor" ] && [ -s "$arquivo_erro_servidor" ]; then
                mensagem_erro_servidor=$(cat "$arquivo_erro_servidor")
            fi
            echo -e "${vermelho}Erro ao iniciar o servidor iperf3 (código: $resultado_servidor_iperf3).${normal}"
            if [ -n "$mensagem_erro_servidor" ]; then
                echo -e "${vermelho}Mensagem de erro: $mensagem_erro_servidor${normal}"
            fi
            exit 1
        fi
    fi

    sleep 1
    mostrar_e_registrar "${amarelo}Preparando o mpstat...${normal}\r" "$log_teste"
    numactl -C 0 $dir_este_script/mpstat-trigger $duracao $dir_resultados_teste/rodada_$rodada_atual rodada_$rodada_atual-${apelido}-mpstat.log 2>&1 < /dev/null &

    sleep 1
    arquivo_erro_cliente="$dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-iperf3_client_erro.log"

    setsid $comando_cliente $args_extras -J -i 1 -t $duracao > $dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-iperf3_client.json 2> "$arquivo_erro_cliente" < /dev/null &
    pid_cliente=$!

    # Verifica se o cliente iperf3 ainda está rodando e encerra se não estiver
    sleep 0.5
    if ! kill -0 $pid_cliente 2>/dev/null; then
        wait $pid_cliente
        resultado_cliente_iperf3=$?
        mensagem_erro_cliente=""
        if [ -f "$arquivo_erro_cliente" ] && [ -s "$arquivo_erro_cliente" ]; then
            mensagem_erro_cliente=$(cat "$arquivo_erro_cliente")
        fi
        echo -e "${vermelho}Erro ao iniciar o cliente iperf3 (código: $resultado_cliente_iperf3).${normal}"
        if [ -n "$mensagem_erro_cliente" ]; then
            echo -e "${vermelho}Mensagem de erro: $mensagem_erro_cliente${normal}"
        fi
        exit 1
    fi

    mostrar_e_registrar "${amarelo}Cliente iniciado${texto_nucleo_cliente}...${normal}" "$log_teste" ; printf "\e[1A\r"
    contagem_regressiva $duracao $quantidade_amostras_omitidas "${amarelo}Cliente iniciado${texto_nucleo_cliente}...${normal}"
    wait $(jobs -p)
    wait $pid_servidor
    resultado_servidor_iperf3=$?

    sleep 1
    # Processa os resultados para CSV
    $dir_este_script/iperf-json-to-csv $dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-iperf3_server.json $quantidade_amostras_omitidas > $dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-iperf3_server.csv 2>/dev/null

    $dir_este_script/iperf-json-to-csv $dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-iperf3_client.json $quantidade_amostras_omitidas > $dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-iperf3_client.csv 2>/dev/null

    cat $dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-mpstat.log | $dir_este_script/mpstat_to_csv.py > $dir_resultados_teste/rodada_$rodada_atual/rodada_$rodada_atual-${apelido}-mpstat.csv
}

ajuda() {
    echo -e "\nUso: $0 [opções]\n"
    echo -e "Opções:"
    echo -e "  -a, --apelido          Apelido para a rodada"
    echo -e "  -t, --duracao          Duração do teste em segundos"
    echo -e "  -r, --rodadas          Número de rodadas a serem executadas"
    echo -e "  -c, --comando-cliente  Comando do cliente iperf3"
    echo -e "  -s, --comando-servidor Comando do servidor iperf3"
    echo -e "  --preparo-antes        Script a ser executado antes do teste"
    echo -e "  --receita              Arquivo de receita com os testes a serem executados"
    echo -e "  -h, --ajuda            Exibe esta ajuda"
}

# Processar os argumentos
while [[ $# -gt 0 ]]; do
    argumento=$1
    case $argumento in
        -a|--apelido)
            apelido=$2
            shift 2
            ;;
        -t|--duracao)
            argumento_duracao=$2
            shift 2
            ;;
        -r|--rodadas)
            argumento_rodadas=$2
            shift 2
            ;;
        --comando-cliente|-c)
            comando_cliente=$2
            shift 2
            ;;
        --comando-servidor|-s)
            comando_servidor=$2
            shift 2
            ;;
        --preparo-antes)
            preparo_antes=$2
            shift 2
            ;;
        --receita)
            arquivo_receita=$2
            shift 2
            ;;
        *)
            echo "Argumento inválido: $1"
            ajuda
            exit 1
            ;;
    esac
done

LANG=C
LC_ALL=C

# Cores
vermelho="\033[1;31m"
verde="\033[1;32m"
amarelo="\033[1;33m"
ciano="\033[1;36m"
rosa="\033[1;95m"
normal="\033[0m"
duracao_padrao=10
duracao=${duracao_padrao}
quantidade_rodadas_padrao=2
rodadas=${quantidade_rodadas_padrao}
testes=()
[ -n "$apelido" ] && testes+=("$apelido")
testes_normalizados=()
dir_este_script=$(dirname $(realpath $0))
dir_resultados="$dir_este_script/resultados"

verifica_dependencias

if [ -z "$arquivo_receita" ]; then
    if [ -z "$apelido" ]; then
        argumentos_faltantes+=("Apelido do teste")
    fi

    if [ -z "$comando_cliente" ]; then
        argumentos_faltantes+=("Comando do cliente")
    fi

    if [ -z "$comando_servidor" ]; then
        argumentos_faltantes+=("Comando do servidor")
    fi

    if [ ${#argumentos_faltantes[@]} -gt 0 ]; then
        if [ ${#argumentos_faltantes[@]} -lt 2 ]; then
            text_argumentos_faltantes="o seguinte argumento está faltando"
        else
            text_argumentos_faltantes="os seguintes argumentos estão faltando"
        fi

        echo -e "\n${vermelho}Erro: ${text_argumentos_faltantes}:${normal}"
        for argumento in "${argumentos_faltantes[@]}"; do
            echo -e "${vermelho}  - $argumento${normal}"
        done
        ajuda
        exit 1
    fi
fi

# Tenta obter a duração da rodada do comando do cliente
duracao_comando_cliente=$(obtem_duracao_do_comando_iperf "$comando_cliente")
if [ -n "$duracao_comando_cliente" ] && [ "$duracao_comando_cliente" -gt $duracao_padrao ]; then
    duracao=$duracao_comando_cliente
fi

if [ -n "$argumento_rodadas" ] && [ "$argumento_rodadas" -gt $quantidade_rodadas_padrao ]; then
    rodadas=${argumento_rodadas}
fi

if [ -n "$argumento_duracao" ] && [ "$argumento_duracao" -gt $duracao_padrao ]; then
    duracao=${argumento_duracao}
fi

if [ -n "$arquivo_receita" ]; then
    texto_inicial=()

    if [ ! -f "$arquivo_receita" ]; then
        echo -e "${vermelho}Erro: arquivo de receita não encontrado: $arquivo_receita${normal}"
        exit 1
    fi

    conteudo_receita=$(cat "$arquivo_receita")

    nome_receita=$(obtem_nome_receita "$conteudo_receita")
    if [ -z "$nome_receita" ]; then
        echo -e "\n${vermelho}Erro: a receita não possui um nome!${normal}\n"
        exit 1
    else
        texto_inicial+="Nome da receita: ${verde}${nome_receita}${normal}\n"
    fi

    descricao_receita=$(obtem_descricao_receita "$conteudo_receita")
    if [ -n "$descricao_receita" ]; then
        texto_inicial+="Descrição da receita: ${verde}${descricao_receita}${normal}\n"
    fi

    if [ -z "$argumento_rodadas" ]; then
        rodadas_receita=$(obtem_rodadas "$conteudo_receita")
        if [ -n "$rodadas_receita" ] && [ "$rodadas_receita" -gt $quantidade_rodadas_padrao ]; then
            rodadas=$rodadas_receita
        fi
    fi

    if [ -z "$argumento_duracao" ]; then
        duracao_receita=$(obtem_tempo_da_rodada "$conteudo_receita")
        if [ -n "$duracao_receita" ] && [ "$duracao_receita" -gt $duracao_padrao ]; then
            duracao=$duracao_receita
        fi
    fi

    testes_receita=$(obtem_nomes_testes "$conteudo_receita")

    if [ -z "$testes_receita" ]; then
        echo -e "${vermelho}Erro: nenhum teste encontrado na receita.${normal}"
        exit 1
    else
        while IFS= read -r teste; do
            # Verifica se o teste já foi adicionado
            if [[ ! " ${testes[@]} " =~ " ${teste} " ]]; then
                testes+=("$teste")
            fi
        done <<< "$testes_receita"
    fi

    texto_inicial+="Quantidade de testes: ${verde}${#testes[@]}${normal}\n"
    texto_inicial+="Quantidade de rodadas: ${verde}${rodadas}${normal}\n"
    texto_inicial+="Duração de cada rodada: ${verde}${duracao} segundos${normal}\n"

    dir_resultados="$dir_resultados/$nome_receita"

    sumarizador_receita=$(obtem_sumarizador "$conteudo_receita")

    echo
    box "${texto_inicial[@]}"
fi

if [ ! -d $dir_resultados ]; then
    mkdir -p $dir_resultados
fi

# Cria a linha horizontal
if [ -z "$boxWidth" ]; then
    boxWidth=50
fi

for ((i = 0; i < boxWidth; i++)); do
    linha_horizontal+="═"
done

# Executa um ou mais testes
for teste in "${testes[@]}"; do
    apelido=$(echo "$teste" | sed 's/ /_/g')
    testes_normalizados+=("$apelido")
    dir_resultados_teste="$dir_resultados/$apelido"
    log_teste="$dir_resultados_teste/$apelido-experimento.log"

    rm -rf $dir_resultados_teste
    mkdir -p $dir_resultados_teste

    mostrar_e_registrar "\n${linha_horizontal//═/#}\n" "$log_teste"

    if [ -n "$arquivo_receita" ]; then
        obtem_teste "$conteudo_receita" "$teste"

        if [ -z "$comando_cliente" ]; then
            echo -e "${vermelho}Erro: comando de cliente não encontrado.${normal}"
            exit 1

        # Se o valor de "comando_servidor" for "true",
        # então a chave está definida na receita, porém não foi preenchida
        elif ! $comando_servidor; then
            echo -e "${vermelho}Erro: comando de servidor não encontrado.${normal}"
            exit 1
        fi
    fi

    echo -e "\nInício: $(date '+%Y-%m-%d %H:%M:%S')" > "$log_teste"
    mostrar_e_registrar "Nome do teste: ${verde}${teste}${normal}" "$log_teste"

    echo "[Teste]" > $dir_resultados_teste/$apelido-conf.ini
    echo "Nome=${teste}" >> $dir_resultados_teste/$apelido-conf.ini

    if [ -n "$descricao_teste" ]; then
        mostrar_e_registrar "Descrição do teste: ${verde}${descricao_teste}${normal}" "$log_teste"
        echo "Descricao=${descricao_teste}" >> $dir_resultados_teste/$apelido-conf.ini
    else
        echo "; Descricao=" >> $dir_resultados_teste/$apelido-conf.ini
    fi

    echo "ComandoCliente=${comando_cliente}" >> $dir_resultados_teste/$apelido-conf.ini

    if [ -z "$comando_servidor" ]; then
        mostrar_e_registrar "Observação: ${amarelo}comando do servidor ausente. Executará somente o cliente.${normal}" "$log_teste"
        echo "; ComandoServidor=" >> $dir_resultados_teste/$apelido-conf.ini
    else
        echo "ComandoServidor=${comando_servidor}" >> $dir_resultados_teste/$apelido-conf.ini
    fi

    if [ -z "$arquivo_receita" ]; then
        mostrar_e_registrar "Quantidade de rodadas: ${verde}${rodadas}${normal}" "$log_teste"
        mostrar_e_registrar "Duração de cada rodada: ${verde}${duracao} segundos${normal}" "$log_teste"
    fi

    mostrar_e_registrar "\nOs resultados do experimento serão salvos em ↓:" "$log_teste"
    mostrar_e_registrar "${verde}$dir_resultados_teste${normal}\n" "$log_teste"

    if [ -n "$preparo_antes" ]; then
        mostrar_e_registrar "Preparando o ambiente antes do teste usando a rotina abaixo ↓:" "$log_teste"
        mostrar_e_registrar "${verde}${preparo_antes}${normal}" "$log_teste"
        echo "PreparoAntes=${preparo_antes}" >> $dir_resultados_teste/$apelido-conf.ini
        bash $preparo_antes > $dir_resultados_teste/$apelido-preparo_antes.log 2>&1
    else
        echo "; PreparoAntes=" >> $dir_resultados_teste/$apelido-conf.ini
    fi

    mostrar_e_registrar "\n${linha_horizontal//═/#}" "$log_teste"

    for rodada_atual in $(seq 1 $rodadas); do
        mostrar_e_registrar "\n${linha_horizontal}" "$log_teste"
        roda_teste "$rodada_atual" "$comando_cliente" "$comando_servidor" "$duracao" "$dir_resultados_teste" "$apelido" "$log_teste"
        mostrar_e_registrar "\n${linha_horizontal}" "$log_teste"
    done

    if [ -n "$preparo_depois" ]; then
        mostrar_e_registrar "\nPreparando o ambiente após o teste usando a rotina abaixo ↓:" "$log_teste"
        mostrar_e_registrar "${verde}${preparo_depois}${normal}" "$log_teste"
        echo "PreparoDepois=${preparo_depois}" >> $dir_resultados_teste/$apelido-conf.ini
        bash $preparo_depois > $dir_resultados_teste/$apelido-preparo_depois.log 2>&1
        mostrar_e_registrar "\n${linha_horizontal}\n" "$log_teste"
    else
        echo "; PreparoDepois=" >> $dir_resultados_teste/$apelido-conf.ini
    fi

    echo
    echo -e "\nFim: $(date '+%Y-%m-%d %H:%M:%S')" >> "$log_teste"
done

if [ -n "$sumarizador_receita" ]; then
    echo -e "\nSumarizando resultados usando a rotina abaixo ↓:"

    # Substitui a variável $DIR_RESULTADOS pelo diretório de resultados
    sumarizador_receita=$(echo "$sumarizador_receita" | sed "s|\$DIR_RESULTADOS|$dir_resultados|g")

    # Substitui as variáveis de teste $Teste[n] pelo nome do teste
    contador=1
    for teste in "${testes_normalizados[@]}"; do
        sumarizador_receita=$(echo "$sumarizador_receita" | sed "s|\$Teste\[$contador\]|$teste|g")
        contador=$((contador + 1))
    done

    # Quebrando o comando em várias linhas para facilitar a visualização
    sumarizador_receita_formatado=$(echo "$sumarizador_receita" | sed 's/ \(-[a-z]\)/ \\\n     \1/g')

    echo -e "${verde}${sumarizador_receita_formatado}${normal}\n"

    echo -e "Os resultados sumarizados serão salvos em ↓:"
    echo -e "${verde}$dir_resultados/${nome_receita}-sumarizador.log${normal}\n"

    echo -e "Executando o sumarizador. O conteúdo do log será exibido abaixo. Por favor, aguarde..."
    bash -c "$sumarizador_receita" | tee $dir_resultados/$nome_receita-sumarizador.log
fi